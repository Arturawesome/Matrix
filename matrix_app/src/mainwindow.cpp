// mainwindow.cpp
#include "mainwindow.h"
#include "ui_mainwindow.h"
#include "matrix.h"
#include "parser.h"
#include <QDebug>
template<typename T>
void add_matrix_text(QString& output, const Matrix<T>& Mat){
    for(int i = 0; i < Mat.GetRow(); ++i){
        for(int j = 0; j < Mat.GetCol(); ++j){
            output += QString::number(Mat.GetVal(i, j), 'f', 1);
            output += " ";
        }
        output += " \n";
    }
}

template<typename T>
void add_scalar_text(QString& output,  T scalar){
    output += QString::number(scalar, 'f', 1);
    output += "\n";
}


int get_index(QString mat_index){
    return mat_index.right(mat_index.size()-1).toInt();
}

MainWindow::MainWindow(QWidget *parent)
            :QMainWindow(parent), ui(new Ui::MainWindow), matrix_amount(0), current_matrix_index(0)
{
    /*
        new Ui::MainWindow: dynamicaly creates the object of Ui::MainWindow,
        which was generated by mainwindow.ui in Qt Creator.
        this object contans interface and all their elements
     */
    ui->setupUi(this);

    // tourn the signal on for changing value of QSpinBox
    connect(ui->spinBoxMatrixCount, SIGNAL(valueChanged(int)), this, SLOT(onMatrixCountChanged(int)) );

    connect(ui->pushButtonSave, &QPushButton::clicked, this, &MainWindow::onNextButtonClicked);

    connect(ui->pushButtonSaveMatrixData, &QPushButton::clicked, this, &MainWindow::onWriteButtonClickedSave);

    connect(ui->pushButtonCalculate, &QPushButton::clicked, this, &MainWindow::onCalculateButtonClicked );


    updatePromt();
    ui->lineEditRow->setEnabled(false);
    ui->lineEditColumn->setEnabled(false);
    ui->pushButtonSave->setEnabled(false);


}

MainWindow::~MainWindow(){
    delete ui;
}
void MainWindow::onMatrixCountChanged(int count){
    matrix_amount = count;
    qDebug() << "Num of Matrix changet to:  "<<count<<"\n";

    if(matrix_amount > 0){
        ui->lineEditRow->setEnabled(true);
        ui->lineEditColumn->setEnabled(true);
        ui->pushButtonSave->setEnabled(true);
        ui->pushButtonSaveMatrixData->setEnabled(false);
        //current_matrix_index++;
        updatePromt();
    }else{
        ui->lineEditRow->setEnabled(false);
        ui->lineEditColumn->setEnabled(false);
        ui->pushButtonSave->setEnabled(false);
    }
}


void MainWindow::onCalculateButtonClicked(){
    QString expression = ui->plainTextEditExpression->toPlainText();
    QString output = "operations: \n";
    //qDebug()<<expression;

    try{
        std::vector<QString> polish_not = process_the_expression(expression);
        std::stack<Matrix<double>> mats;
        std::stack<double> scalar;


        Matrix<double> mat_1;
        Matrix<double> mat_2;

        QString mat_1_str, mat_2_str;
        double scalar_number1, scalar_number2;

        qDebug()<<"Show Polish Annotation:\n";
        for(QString el:polish_not){
             qDebug()<<el<<" ";
        }
        qDebug()<<"\n\n";

        for(QString el:polish_not){
            if(is_operator(el)){
                if(el == "det"){
                    output += "det \n";
                    mat_1 = mats.top();
                    add_matrix_text(output, mat_1);
                    mats.pop();
                    scalar.push(mat_1.GetDeterminant());


                    output += " = \n";
                    add_scalar_text(output, scalar.top());
                    output += "\n\n";
                } else if (el == "T."){
                    mat_1 = mats.top();
                    output += "T. \n";
                    add_matrix_text(output, mat_1);
                    mats.pop();
                    mats.push(mat_1.Transp());


                    output += " = \n";
                    add_matrix_text(output, mats.top());
                    output += "\n\n";

                } else if(el == "-") {
                    if(mats.size() < 2) throw std::invalid_argument("Not enough matrices for determinant.");
                    mat_1 = mats.top();
                    mats.pop();
                    mat_2 = mats.top();
                    mats.pop();
                    mats.push(mat_2 - mat_1);

                    add_matrix_text(output, mat_1);
                    output += " -- \n";
                    add_matrix_text(output, mat_2);
                    output += " == \n";
                    add_matrix_text(output, mats.top());
                    output += "\n \n";

                } else if(el == "+") {
                    if(mats.size() < 2) throw std::invalid_argument("Not enough matrices for determinant.");
                    mat_1 = mats.top();
                    mats.pop();
                    mat_2 = mats.top();
                    mats.pop();
                    mats.push(mat_1 + mat_2);

                    add_matrix_text(output, mat_1);
                    output += " ++ \n";
                    add_matrix_text(output, mat_2);
                    output += " == \n";
                    add_matrix_text(output, mats.top());
                    output += "\n \n";
                } else if (el == "*") {
                    if(scalar.empty()){
                        // multiply of two matrix
                        if(mats.size() < 2) throw std::invalid_argument("Not enough matrices for determinant.");
                        mat_1 = mats.top();
                        mats.pop();
                        mat_2 = mats.top();
                        mats.pop();
                        mats.push(mat_1 * mat_2);

                        add_matrix_text(output, mat_1);
                        output += " ** \n";
                        add_matrix_text(output, mat_2);
                        output += " == \n";
                        add_matrix_text(output, mats.top());
                        output += "\n \n";

                    } else {
                        // multiply matrix by number
                        if (scalar.size() > 1) {
                            scalar_number1 = scalar.top();
                            add_scalar_text(output, scalar_number1);
                            scalar.pop();
                            output += " * \n";
                            scalar_number2 = scalar.top();
                            add_scalar_text(output, scalar_number2);
                            scalar.pop();
                            output += " = ";

                            scalar.push(scalar_number1*scalar_number2);
                            add_scalar_text(output, scalar.top());
                            output += " \n\n ";
                        } else {
                            scalar_number1 = scalar.top();
                            scalar.pop();
                            add_scalar_text(output, scalar_number1);
                            output += " * \n";
                            mat_1 = mats.top();
                            mats.pop();
                            add_matrix_text(output, mat_1);
                            output += " == \n";
                            mats.push(mat_1 * scalar_number1);
                            add_matrix_text(output, mats.top());
                        }

                    }
                }
            } else {
                if (el.startsWith("M")) {

                    int id_mat = el.right(el.length() - 1).toInt() -1;
                    list_of_matrix[id_mat].ShowMatrix();
                    qDebug()<<el<<";  "<<id_mat;

                    mats.push(list_of_matrix[id_mat]);
                } else {
                    scalar.push(el.toDouble());
                }
            }
        }
        if(!mats.empty()){
            mats.top().ShowMatrix();
        } else if (!scalar.empty()){
            qDebug()<<scalar.top();
        }
        ui->textBrowserAnswer->setText(output);

    } catch (const std::invalid_argument& e) {
        //QMessageBox::warning(this, "Error", QString("Invalid expression: %1").arg(e.what()));
        ui->labelExpressionResult->setText("Error in expression!");
    }

    return;
}


void MainWindow::onWriteButtonClickedSave(){
    int id_matrix = matrix_amount - current_matrix_index;
    qDebug()<<"id_matrix = "<<id_matrix<<"\n";
    qDebug()<<"current_matrix_index = "<<current_matrix_index<<"\n";

    QString matrixData = ui->plainTextEditMatrixData->toPlainText();
    list_of_matrix[id_matrix].WriteMatrix(matrixData);
    list_of_matrix[id_matrix].ShowMatrix();

    cleanWriteMatrixWindow();
    current_matrix_index--;

    if(current_matrix_index <= 0){
        ui->pushButtonSaveMatrixData->setEnabled(false);
        ui->plainTextEditMatrixData->setEnabled(false);
    } else {
        updateDataWindow(id_matrix+2, list_of_matrix[id_matrix+1]);
    }

}

void MainWindow::onNextButtonClicked(){
    int row, col;

    row = ui->lineEditRow->text().toInt();
    col = ui->lineEditColumn->text().toInt();
    Matrix<double> data(row, col);
    qDebug()<<"onNextButtonClicked after Matrix<double> data(row, col)\n";
    list_of_matrix.push_back(data);
    qDebug()<<" after list_of_matrix.push_back(data); \n";
    current_matrix_index++;

    if(current_matrix_index >= matrix_amount){
        qDebug()<<"All Matrixs are created\n";
        ui->labeRowColInput ->setText("All matrixes are created");
        ui->lineEditRow->setEnabled(false);
        ui->lineEditColumn->setEnabled(false);
        ui->pushButtonSave->setEnabled(false);

        ui->pushButtonSaveMatrixData->setEnabled(true);
        ui->plainTextEditMatrixData->setEnabled(true);
        updateDataWindow((matrix_amount - current_matrix_index) + 1, list_of_matrix[(matrix_amount - current_matrix_index)]);


    }else{
        updatePromt();
        cleanInputRowCol();
    }
}

void MainWindow::updateDataWindow(int count, const Matrix<double>& data){
    qDebug()<<"updateDataWindow\n";
    QString info = QString("Write Matrix %1: row = %2, col = %3").arg(count).arg(data.GetRow()).arg(data.GetCol());
    ui->labeWriteMatrix ->setText(info);
}
void MainWindow::updatePromt(){
    // Qstring - field of qt6.
    // Arg - function for changeing infro after % in Qstring
    QString promt = QString("Write the number of rows and columns in Matrix %1").arg(current_matrix_index+1);
    // I set name in Qt creator for Qlabel labeRowColInput -> ui->labeRowColInput for changeing
    ui->labeRowColInput ->setText(promt);
}
void MainWindow::cleanWriteMatrixWindow(){
    ui->plainTextEditMatrixData ->clear();
}

void MainWindow::cleanInputRowCol(){
    //clean the text fileds
    ui->lineEditRow->clear();
    ui->lineEditColumn->clear();
}
















